# テストパターン集

## 基本パターン

### 1. 単純な値のテスト
```
テスト: 2つの数値を足し算する
- 準備: 2 と 3
- 実行: add(2, 3)
- 検証: 結果が 5 である
```

### 2. 非同期処理のテスト
```
テスト: ユーザーデータを取得する
- 準備: ユーザーID 1
- 実行: fetchUser(1) を await
- 検証:
  - id が 1 である
  - name が定義されている
```

### 3. エラーハンドリングのテスト
```
テスト: 無効なメールアドレスでエラーをスローする
- 準備: 無効なメールアドレス "invalid"
- 実行: validateEmail("invalid")
- 検証: エラーがスローされる
```

## モックパターン

### 1. 依存関係のモック
```
テスト: ユーザーを作成する（リポジトリをモック）
- 準備:
  - モックリポジトリを作成
  - save メソッドが固定値を返すよう設定
- 実行: service.createUser(data)
- 検証:
  - リポジトリの save が呼ばれた
  - 返り値が期待通り
```

### 2. 外部API呼び出しのモック
```
テスト: 天気情報を取得する
- 準備: HTTP クライアントをモック
- 実行: getWeather("Tokyo")
- 検証: モックから返された値が使われる
```

## エッジケースパターン

### 1. 空配列・null・undefined
```
テスト: 空配列を処理する → 空配列を返す
テスト: nullを処理する → 空配列を返す
テスト: undefinedを処理する → 空配列を返す
```

### 2. 境界値テスト
```
テスト: 最小値(0)を受け入れる → true
テスト: 最大値(150)を受け入れる → true
テスト: 負の値を拒否する → false
テスト: 最大値を超える値を拒否する → false
```

## 統合テストパターン

### 1. データベーステスト
```
テスト: ユーザーを保存して取得する
- 準備: テストDBをセットアップ
- 実行:
  - save でユーザーを保存
  - findById で取得
- 検証: 保存したデータが取得できる
- 後処理: テストDBをクリーンアップ
```

### 2. APIエンドポイントテスト
```
テスト: POST /api/users で新しいユーザーを作成する
- 準備: リクエストボディを用意
- 実行: POST リクエストを送信
- 検証:
  - ステータスコード 201
  - レスポンスに user が含まれる
  - パスワードはレスポンスに含まれない
```

## テスト設計のヒント

### テストの独立性
- 各テストは他のテストに依存しない
- テストの実行順序に依存しない
- 共有状態を避ける

### テストの可読性
- テスト名だけで何をテストしているかわかる
- Arrange-Act-Assert の構造を明確に
- マジックナンバーを避け、意味のある変数名を使う

### テストのメンテナンス性
- DRYより可読性を優先
- ヘルパー関数は慎重に（過度な抽象化を避ける）
- テストデータはテスト内で明示的に定義
